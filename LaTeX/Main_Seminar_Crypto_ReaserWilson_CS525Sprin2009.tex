% Ron Reaser / Chris Wilson
% Presentation 2
% CS 525
% Spring 2009


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\documentclass[smaller, 8pt]{beamer}

\usepackage{xcolor, graphicx, pgf, tikz}
\usepackage{enumerate, algorithmic}
\usepackage[english]{babel}

\usetheme{Warsaw} % Warsaw or Berkeley
\setbeamertemplate{navigation symbols}{}
\setbeamercovered{dynamic} % dynamic or transparent
\usefonttheme[onlysmall]{structurebold}
\setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]

\title{Cryptography}
\author[Reaser \and Wilson]{
	Ron Reaser \and Chris Wilson
}
\institute[WVU]{
	Lane Department of Computer Science and Electrical Engineering \\
	West Virginia University
}
\date{April 28, 2009}

\providecommand{\bigo}{\ensuremath{\mathcal{O}}}

\providecommand{\todo}[1]{{\color{red} TO DO: #1}}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


\begin{document}
	
	\frame{ \titlepage }

	\frame{ \tableofcontents[pausesections] }

	\AtBeginSubsection[] { \frame{ \tableofcontents[current,currentsubsection] } }

	\section{Theory}

		\subsection{Purpose and Examples}

			\frame{
				\begin{block}{Definition}
					Encryption is a method used by two parties to ensure secrecy if their communications are intercepted by a malevolent third party. \pause \medskip \\
					The parties agree on two polynomial time algorithms $E$ and $D$ assumed to be known to the general public. \pause Some values $e$ and $d$ are chosen. These are called keys. \pause The sender computes the encrypted message $y$, called ciphertext, as $E(e, x) = y$ for some original message $x$. \pause The receiver then computes the decrypted message, called plaintext, as $D(d, y) = x$. \pause The keys are selected such that $D$ is the inverse of $E$. \pause There should be no way of computing $x$ from $y$ easily without knowing $d$.
				\end{block}
			}

			\frame{
				\begin{exampleblock}{One-Time Pad}
					One can choose both $d$ and $e$ to be the same arbitrary string $e$ of length $x$. \pause \medskip \\
					Let both $E$ and $D$ merely be the {\it exclusive-or} operator. That is, $E(e, x) = e \oplus x$ and $D(e, y) = e \oplus y$. \pause No eavesdropper can deduce $x$ from $y$ without first knowing e.
				\end{exampleblock} \pause
				\begin{block}{Observation}
					The key and message length must be exactly the same for the {\it exclusive-or} to work. \pause Further, the key must be agreed upon and transmitted securely. \pause Both of these problems make the use of a one-time pad undesirable, especially for frequent communication.
				\end{block}
			}

		\subsection{Public-Key Cryptosystems}

			\frame{
				\begin{block}{Definition}
					Modern cryptography relies on the separation of encode and decode keys. \pause The encoding and decoding functions are still $E$ and $D$ respectively, but the decoding key is now $d$ and is distinct from the encoding key $e$, so that $D(d, E(e, x)) = x$. \pause An $(e, d)$ pair is generated by an individual who makes $e$ known publicly but keeps $d$ private. \pause The point is that it is intentionally infeasible to deduce $d$ even knowing $e$, making it computationally hard to recover $x$ from $y$ without knowing $d$. \pause \medskip \\
					This is called a public-key cryptosystem. \pause
				\end{block}
				\begin{block}{Observation}
					The safety of a public-key cryptosystem lies in the difficulty of guessing $x$ given $y$. So there can be no impossibility proof as there was for the one-time pad. \pause Checking all $x$ until $E(e, x) = y$ can find the original message. \pause Since $x$ cannot be more than polynomially longer than $y$, this problem is in {\bf FNP}.
				\end{block}
			}

		\subsection{One-Way Functions}

			\frame{
				\begin{block}{Definition}
					Public-key cryptosystems are secure only if {\bf P} $\ne$ {\bf NP}. \pause Even so, they are not guaranteed to be secure without utilizing a special function called a one-way function and described as follows. \pause
					\begin{enumerate}[(i)]
						\item The function $f$ is one-to-one, so $x = f^{-1}(f(x))$ for any input $x$. \pause
						\item The value $f(x)$ is at most polynomially longer or shorter than $x$. \pause
						\item The function $f$ is in {\bf FP}, so it can be computed in polynomial time. This constitutes encoding, which is necessarily easy. \pause
						\item The inverse function $f^{-1}$ is in {\bf FNP}, so it cannot be computed in polynomial time. This constitutes decoding, which is intentionally difficult.
					\end{enumerate} \pause
					There is currently no guarantee that such functions exist even if {\bf P} $\ne$ {\bf NP}, but they are believed to exist as will be shown in the following examples.
				\end{block}
			}

			\frame{
				\begin{exampleblock}{Integer Multiplication of Primes}
					One function that many suspect is indeed a one-way function is the integer multiplication of primes. \pause \medskip \\
					Supposed that $p < q$ are prime numbers and $C(p)$ and $C(q)$ are certificates of their primality. \pause The function $f_{MULT}(p, C(p), q, C(q)) = p \cdot q$ is indeed one-to-one and computable in polynomial time. \pause Nevertheless there is no known polynomial time algorithm to compute ${f_{MULT}}^{-1}$ and thereby factor the product of two large primes.
				\end{exampleblock}
			}

			\frame{
				\begin{exampleblock}{Exponentiation Modulo a Prime}
					The function $f_{EXP}$, exponentiation modulo a prime, takes as parameters a prime $p$ with a certificate $C(p)$ guaranteeing primality, \pause a primitive root $r$ modulo $p$ that is part of $C(p)$, \pause and an arbitrary integer $x < p$. \pause \medskip \\
					By definition, $f_{EXP}(p, C(p), r, x) = (p, C(p), r^x$ mod $p)$, which can be evaluated in polynomial time. \pause Determining $x$ given $(r, p, r^x$ mod $p)$ is known as the discrete logarithm problem, and there is no known polynomial time algorithm to solve it. \pause \medskip \\
					Since $f_{EXP}$ is in {\bf P} and ${f_{EXP}}^{-1}$ is not known to be, $f_{EXP}$ is believed to be one-way.
				\end{exampleblock}
			}

			\frame{
				\begin{block}{Assertion}
					The following function, RSA, is one-way. It can be computed in polynomial time, yet no polynomial algorithm for inverting it has ever been announced.
				\end{block} \pause
				\begin{exampleblock}{RSA}
					Combining $f_{MULT}$ and $f_{EXP}$ as a public-key cryptosystem is called RSA. \pause This stands for Rivest, Shamir, and Adleman, the scientists who devised the function at MIT in 1977. \pause \medskip \\
					Let $p$ and $q$ be two prime numbers. The number of bits in their product $pq$ is $n = \lceil \ln pq \rceil$. \pause All numbers modulo $pq$ will be considered as $n$-bit strings over $\{0, 1\}$. \pause \medskip \\
					Let $\phi(pq)$ be $pq(1 - \frac{1}{p})(1 - \frac{1}{q}) = pq - p - q + 1$. \pause Assume that the key $d$ is just a number that is relatively prime to $\phi(pq)$. \pause The RSA function is defined to be $f_{RSA}(x, e, p, C(p), q, C(q)) = (x^e \mod pq, pq, e)$.
				\end{exampleblock}
			}

			\frame{
				\begin{exampleblock}{RSA (Continued)}
					Bob knows $p$ and $q$, and he shares with Alice their product $pq$. \pause He also shares a publicly-known integer $e$ that is relatively prime to $\phi(pq)$. \pause \medskip \\
					Alice uses the public key to encrypt the message $x$, an $n$-bit integer, as follows: $y = x^e \mod pq$. \pause Bob alone knows an integer $d$ such that $ed = 1 + k\phi(pq)$ for some integer $k$. \pause \medskip \\
					Bob can decrypt $y$ as follows: $y^d = x^{ed} = x^{1 + k\phi(pq)} = x \mod pq$. \pause \medskip \\
					So the encryption key is actually $(pq, e)$ and the decryption key $(pq, d)$. 
				\end{exampleblock} \pause
				\begin{block}{Observation}
					All attempts to ``break'' RSA will be at least as hard as inverting $f_{MULT}$.
				\end{block}
			}

		\subsection{Randomization}

			\frame{
				\begin{block}{Observation}
					Sufficiently short messages may be easy to decode with a regular public-key cryptosystem. \pause Specifically, a message composed of one bit, either $0$ or $1$, would be very easy to decode because the always one-to-one mapping can be exploited.
				\end{block} \pause
				\begin{block}{Solution}
					This weakness can be patched for single-bit or other short messages by padding the unencoded message with randomized junk bits. \pause For example, instead of encoding a bit $x$, encode a message $2k + x$ where $k$ is a random integer. \pause Because $2k$ is even, the last bit in the sum will be the $x$ bit. \pause However, because there are as many possible one-to-one mappings for this $k$-padded $x$ bit as there are choices for $k$, the encoded message is much harder to decrypt without knowing the private key.
				\end{block} \pause
				\begin{block}{Application}
					Rather than using a plain public-key cryptosystem, one can break a message into many parts, padding each part with a random bit string, and send each encoded alone. \pause Although this slows down both the encoding and decoding, the decoding is still fast enough for the intended recipient while even harder for an assailant. \pause This is called a randomized public-key cryptosystem.
				\end{block}
			}

	\section{Applications}

		\subsection{Protocols}

			\frame{
				\begin{block}{Concept}
					Compared to previous studies in computational complexity, encryption is a significant departure. \pause In most of the problems studied so far, there has been one agent (the algorithm) and one problem and a goal of being as efficient as possible. \pause With cryptosystems, there are often multiple agents in the system, and it is the goal to make certain tasks easy for some agents and difficult for others. \pause Steps to achieve this constitute a protocol.
				\end{block}
			}

		\subsection{Signed Messages}

			\frame{
				\begin{block}{Definition}
					Suppose Alice wants to send Bob a message and ensure that he will know it was truly sent by her. \pause Such a message $S_{Alice}(x)$ should contain the original $x$ plus something which unmistakably identifies the sender. \pause Such a process is called signing a message and can be achieved using a public-key cryptosystem. \pause
				\end{block}
				\begin{block}{Algorithm}
					Suppose Alice has the key pair $(e_{Alice}, d_{Alice})$ and Bob $(e_{Bob}, d_{Bob})$ \pause and that the encoding and decoding functions $E$ and $D$ are the same for both Alice and Bob. \pause \medskip \\
					Alice starts by creating a signed message $S_{Alice}(x) = (x, D(d_{Alice}, x))$. That is, she sends Bob an original message $x$ as well as its decryption (rather than encryption) using her private key. \pause (The entire signed message can then be encrypted using Bob's public key to keep it secret, but this step is outside the scope of message signing.)
				\end{block}
			}

			\frame{
				\begin{block}{Algorithm (Continued)}
					When Bob receives the message, he encodes (rather than decodes) the decrypted part using Alice's public key. That is, he finds $E(e_{Alice}, D(d_{Alice}, x))$. \pause This is the same thing as $D(d_{Alice}, E(e_{Alice}, x))$, because encoding and decoding are inverse functions. \pause This inversion yields $x$. So given the message $(x, D(d_{Alice}, x))$ Bob is able to find $(x, x)$. \pause \medskip \\
					This confirms that the sender had Alice's private key. Bob can plausibly believe she sent the message. \pause This signing approach is only secure if the private keys are.
				\end{block}
			}

		\subsection{Mental Poker}

			\frame{
				\begin{block}{Mental Poker}
					Mental poker refers to a set of cryptographic problems that concern playing a fair game over distance without the need for a trusted third party. \pause The term is also applied to the theories surrounding these problems and their possible solutions. \pause The name stems from the card game poker, one of the games to which this kind of problem applies. \pause A similar problem is flipping a coin over a distance. \pause \medskip \\
					The problem can be described as follows: ``How can one allow only authorized agents to have access to certain information while not using a trusted arbiter?'' \pause Note that eliminating the trusted third-party avoids the problem of trying to determine whether the third party can be trusted or not. \pause This may also reduce the resources required. \pause \medskip \\
					Mental poker requires a commutative algorithm, an algorithm where the order of encryption does not matter.
				\end{block} \pause
				\begin{exampleblock}{Example}
					An algorithm for shuffling cards using commutative encryption would be as follows.
				\end{exampleblock}
			}

			\frame{
				\begin{exampleblock}{Shuffling Cards} \small
					\begin{enumerate}[(1)]
						\item Alice and Bob agree on a ``deck'' of cards. This abstracts an arbitrary data set. \pause
						\item Alice picks an encryption key $a$ and uses this to encrypt each card of the deck. \pause
						\item Alice shuffles the cards. \pause
						\item Alice passes the deck to Bob. \pause
						\item Bob picks an encryption key $b$ and uses this to again encrypt each card of the deck. \pause
						\item Bob shuffles the deck. \pause
						\item Bob passes the deck back to Alice. \pause
						\item Alice decrypts each card using her key $a$, leaving only Bob's encryption in place. \pause
						\item Alice picks an encryption key $a_i$ for each $i$-numbered card and encrypts them individually. \pause
						\item Alice passes the deck to Bob. \pause
						\item Bob decrypts each card using his key $b$, leaving only Alice's encryption in place. \pause
						\item Bob picks an encryption key $e_j$ for each $j$-numbered card and encrypts them individually. \pause
						\item Bob passes the deck back to Alice. \pause
						\item Alice repeats steps 2 to 4 and 8 to 10 with each additional player besides Bob. \pause
						\item Alice publishes the deck for everyone playing.
					\end{enumerate}
				\end{exampleblock}
			}

		\subsection{Interactive Proofs}

			\frame{
				\begin{block}{Concept}
					Suppose Eric has exponential computing powers while Paula has strictly polynomial computing powers. \pause Eric can decide some {\sc Problem} in {\bf NP} on any input. \pause He wants to prove {\sc Problem}$(x)$ to Paula given that they both know some input $x$. \pause \medskip \\
					If {\sc Problem}$(x) =$ ``yes,'' Eric can find in exponential time a ``yes'' certificate to show Paula such that she can verify it in polynomial time. \pause If however {\sc Problem}$(x) =$ ``no,'' Eric cannot prove this to Paula because he cannot provide a ``yes'' certificate. She would have to reject the input herself, and that would require exponential time. \pause \medskip \\
					However, utilizing randomization and a series of alternating messages, Eric can make Paula probabilistically sure that {\sc Problem}$(x) =$ ``no'' if it does in fact reject without violating her time constraints. This is called an interactive proof.
				\end{block} \pause
				\begin{exampleblock}{Example}
					This is most intuitively explained through an example, although the protocol can be generalized quite clearly for other problems in {\sc NP}.
				\end{exampleblock}
			}

			\frame{
				\begin{exampleblock}{Graph Isomorphism}
					The problem of {\sc Graph Isomorphism} is one of the few {\bf NP} problems that is not specifically known to be in {\bf P} or {\bf NP}-complete. \pause Eric wants to prove to Paula the he can decide this problem. \pause The following experiment is conducted several times honestly and accurately. \pause
					\begin{enumerate}[(i)]
						\item Eric sends Paula a non-isomorphic graph pair $(G_1, G_2)$. \pause
						\item Paula chooses either $G_1$ or $G_2$ randomly and permutes it into a new graph $H$. \pause She then sends Eric the graph $H$ as a challenge. \pause
						\item Eric determines which of $G_1$ and $G_2$ is isomorphic to $H$ and sends back a response of $1$ or $2$ accordingly. \pause
						\item Paula verifies whether the response corresponds to the graph she originally chose to permute. Eric passes the challenge if and only if he was correct.
					\end{enumerate} \pause
					At the end, Eric will have always managed to respond correctly to Paula's challenge. \pause After so many passed challenges, it becomes less and less likely that Eric does not actually have the ability to decide {\sc Graph Isomorphism}. \pause Paula can probabilistically trust Eric if he declares two graphs either isomorphic or non-isomorphic. \pause Further, Paula never used more than polynomial time computations.
				\end{exampleblock}
			}

			\frame{
				\begin{block}{Definition}
					The class of all problems solvable with an interactive proof is called {\bf IP}. So {\sc Graph Isomorphism} is in {\bf IP}.
				\end{block} \pause
				\begin{block}{Observation}
					The class {\bf NP} is just a subclass of {\bf IP} where Paula uses no randomization. \pause Further, the class {\bf BPP} is a subset of {\bf IP} where Paula ignores all of Eric's messages. \pause Finally, it so happens that {\bf IP} has been proven identical to {\bf PSPACE}.
				\end{block}
			}

		\subsection{Zero-Knowledge Proofs}

			\frame{
				\begin{block}{Definition}
					There is an interesting subset of interactive proofs in which the participants have the same computational power but there is an added secrecy requirement. \pause \medskip \\
					Suppose that Peggy wants to prove something in such a way that Victor can verify it without actually knowing how to prove it himself. \pause Before it was merely the case that Paula was computationally incapable of using Eric's method. In this case, Peggy simply does not want Victor to know the method. \pause A protocol to achieve this is called a zero-knowledge proof.
				\end{block} \pause
				\begin{exampleblock}{Examples}
					As before, this will be explained through an example that is easily generalized.
				\end{exampleblock}
			}

%			\frame{
%				\begin{exampleblock}{Magic Gate}
%					Peggy and Victor are in a room with two differently labeled exit doors connecting to the same hallway outside. \pause There is a barrier in the middle of the hallway that blocks it off. \pause This is all public information. \pause \medskip \\
%					Peggy claims she has a secret word which will open a magic gate to pass through the barrier. \pause She wants to convince Victor of this without actually telling him the word. \pause \medskip \\
%					The zero-knowledge proof requires honest participation from both Peggy and Victor in conducting the following experiment in alternating steps.
%				\end{exampleblock}
%			}

%			\frame{
%				\begin{exampleblock}{Magic Gate (Continued)}
%					\begin{enumerate}
%						\item Victor closes his eyes, staying in the room. \pause
%						\item Peggy chooses one of the doors via coin toss and exits through it into the hallway until she reaches the barrier, out of sight from the room. \pause
%						\item Victor opens his eyes, still staying in the room. He does not know which door Peggy left through. \pause He chooses one of the doors via coin toss and shouts its label. \pause
%						\item Peggy must return through the correct door, using the magic gate by quietly speaking the secret word if she has to bypass the barrier.
%					\end{enumerate}
%				\end{exampleblock}
%			}

%			\frame{
%				\begin{exampleblock}{Magic Gate (Continued)}
%					With just one experiment, there is a probability of half that Peggy merely guessed where she would need to return from without actually using any magic gate. \pause As the experiments continue with Peggy always correct, the probability is cut in half each time that she was able to guess Victor's random choices. \pause After a certain number of experiments Victor can be almost certain that Peggy does in fact know a secret word to control this once-fanciful magic gate. \pause \medskip \\
%					If both Peggy and Victor are honest in conducting this experiment, Peggy will have succeeded in a zero-knowledge proof.
%				\end{exampleblock}
%			}

			\frame{
				\begin{exampleblock}{Hamilton Cycle}
					Suppose that both Peggy and Victor are familiar with a graph $G$ and that Peggy alone knows a tour in it. \pause For some reason, she wants to convince Victor that she knows a tour without giving it to him. \pause Perhaps she wants to sell him the knowledge, or perhaps she is using it as her signature. Regardless, Victor is willing to entertain her for a coveted solution to an instance of this {\bf NP}-complete problem.
				\end{exampleblock}
			}

			\frame{
				\begin{exampleblock}{Hamilton Cycle (Continued)}
					As before, they undertake the following experiment honestly in alternation. \pause
					\begin{enumerate}[(i)]
						\item Peggy privately creates a graph $H$ isomorphic to $G$. \pause For each edge in $H$, Peggy creates an index card describing its mapping as $(i', j') \in H \mapsto (i, j) \in G$. \pause She puts all of these cards face-down on a table. From now on she is unable to change the $H$ she has committed to, but Victor does not yet know its structure. \pause
						\item Victor flips a coin to choose one of two questions with which to challenge Peggy. \pause
						\begin{enumerate}[(a)]
							\item If he asks to be shown that $H$ and $G$ are indeed isomorphic, Peggy turns over all of the cards. \pause Victor can then verify the isomorphism based on the node mappings, but he will not find out anything about a possible tour. \pause
							\item If instead Victor asks to be shown a tour in $H$, she turns over just the cards that are in the tour. \pause Victor can verify that there is a tour in $H$ based on the edges shown, but he will not know whether $H$ and $G$ are truly isomorphic because he is missing part of $H$.
						\end{enumerate} \pause
						\item Peggy burns all of the cards, or maybe if she is thoughtful she recycles them. \pause
						\item Victor verifies that Peggy was able to pass his challenge.
					\end{enumerate} \pause
					Note that the cards are an abstraction for encryption and decryption and that the coin flip is an abstraction for randomization.
				\end{exampleblock}
			}

			\frame{
				\begin{exampleblock}{Hamilton Cycle (Continued)}
					With each successive experiment it becomes less and less likely that Peggy always guessed which challenge Victor would choose to be able to pass it rather than being prepared for both by actually knowing the tour. \pause After sufficiently many tests, Victor will be probabilistically certain that Peggy does indeed know a tour in $G$, yet he will not himself know the tour. \pause \medskip \\
					With $k$ tests, his doubt $\frac{1}{2^k}$ approaches $0$. With just $7$ tests this is less than $1\%$. \pause \medskip \\
					If Peggy were dishonest, she could rig Victor's coin so that she would not actually have to know a tour in $G$ to pass all of the challenges: she could just be prepared to pass whichever was chosen. \pause It is assumed, however, that Peggy's behavior is honest.
				\end{exampleblock}
			}

\end{document}

%eof
